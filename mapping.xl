// Mapping module definition
//
// This module defines mapping techniques.
//
// Copyright 20010-2011 Taodyne

module_description
    id "a2cdbc99-ce81-42b2-a218-f51938ef2414"
    name "Mapping"
    import_name "Mapping"
    description "Allow to add details in a scene thanks to a surface texture"
    author "Taodyne SAS"
    website "http://www.taodyne.com"
    version "1.0"

module_description "fr",
    name "Mappage"
    description "Permet d'ajouter des détails visuels dans une scène à partir d'images."

// Check if GL_EXT_gpu_shader4 is supported in Tao
SHADER4_AVAILABLE_MAPPING -> true
SHADER4_AVAILABLE_MAPPING := is_ext_available "GL_EXT_gpu_shader4"

HAS_COLOR_MAP -> 0
HAS_COLOR_MAP := 0

has_color_map ->
    /**
    * Check if there is really a color map bound on texture unit 0
    **/
    if (has_texture 0) then
        HAS_COLOR_MAP := 1
    else
        HAS_COLOR_MAP := 0

enable_pixel_blur ->
    /**
    * This trick enables blur on pixels of the result texture
    **/
    rotatex 0.05
    rotatex -0.05

// -------------------------------------------------------------------------------------------------------------------
//   ALPHA MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Alpha_mapping
// -------------------------------------------------------------------------------------------------------------------

//Define alpha thresold
ALPHA_THRESHOLD -> 0.01
ALPHA_THRESHOLD := 0.01


alpha_mapping n:real ->
    /**
    * Apply alpha mapping with a full support of lights.
    **/
    has_color_map
    enable_pixel_blur
    ALPHA_THRESHOLD := n
    if SHADER4_AVAILABLE_MAPPING = false then
        alpha_shader_no_lights
    else
        alpha_shader_lights


alpha_shader_lights ->
    /**
    * Define alpha shader.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            void main()
            {
                // Compute position
                gl_Position = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;

                // Compute world position and normal
                normal  = gl_NormalMatrix * gl_Normal;
                viewDir = -vec3(gl_ModelViewMatrix * gl_Vertex);

                color = gl_Color;
            }
        >>
        fragment_shader <<
            #extension GL_EXT_gpu_shader4 : require

            // Mapping paramaters
            uniform int       lights;
            uniform bool      hasColorMap;
            uniform float     threshold;
            uniform sampler2D alphaMap;
            uniform sampler2D colorMap;

            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene.
            **/
            vec4 computeRenderColor(vec4 renderColor)
            {
                vec4 lighting_color = renderColor;
                if(lights > 0)
                {
                    // Define a maximum of lights supported
                    int MAX_LIGHTS = 8;

                    vec3 N = normalize(normal);
                    vec3 V = normalize(viewDir);

                    vec4 ambient  = vec4(0.0);
                    vec4 diffuse  = vec4(0.0);
                    vec4 specular = vec4(0.0);
                    ambient = gl_FrontLightModelProduct.sceneColor
                            * gl_FrontMaterial.ambient;

                    // Compute render for each enabled lights
                    for(int i = 0; i < MAX_LIGHTS; i++)
                    {
                        if(bool(lights & (1 << i)))
                        {
                            vec3 L = normalize(gl_LightSource[i].position.xyz);

                            // Compute ambient part
                            ambient += gl_LightSource[i].ambient * gl_FrontMaterial.ambient;

                            // Diffuse coefficient
                            float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                            if (nDotL > 0.0)
                            {
                                // Compute diffuse part
                                diffuse += gl_LightSource[i].diffuse
                                         * gl_FrontMaterial.diffuse
                                         * nDotL;

                                // Compute specular coefficient
                                float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                                if (nDotV > 0.0)
                                {
                                    // Compute specular part
                                    specular += gl_LightSource[i].specular
                                              * gl_FrontMaterial.specular
                                              * pow(nDotV, gl_FrontMaterial.shininess);
                                }
                            }
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;
                }

                return lighting_color;
            }

            void main()
            {
                vec4 alpha_color = texture2D(alphaMap, gl_TexCoord[1].st);

                // Filter alpha map according to the threshold
                if(alpha_color.r < threshold
                && alpha_color.g < threshold
                && alpha_color.b < threshold)
                    discard;

                // Get color map
                vec4 mainColor = texture2D(colorMap, gl_TexCoord[0].xy);

                // Check if there is really a color map
                if(hasColorMap)
                    mainColor *= color;
                else
                    mainColor  = color;

                gl_FragColor  = computeRenderColor(mainColor);
            }
        >>
    shader_set colorMap    := 0               // Unit of the color map
    shader_set alphaMap    := 1               // Unit of the alpha map
    shader_set threshold   := ALPHA_THRESHOLD // Threshold of the mapping
    shader_set lights      := lights_mask     // Bitmask of all enabled lights
    shader_set hasColorMap := HAS_COLOR_MAP   // Check if there is a color map


alpha_shader_no_lights ->
    /**
    * Define alpha shader with no lights supported.
    * This is needed in case where GL_EXT_gpu_shader4 is not available.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec4 color;
            void main()
            {
                // Compute position
                gl_Position = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;

                color = gl_Color;
            }
        >>
        fragment_shader <<
            // Mapping paramaters
            uniform bool      hasColorMap;
            uniform float     threshold;
            uniform sampler2D alphaMap;
            uniform sampler2D colorMap;

            varying vec4 color;
            void main()
            {
                vec4 alpha_color = texture2D(alphaMap, gl_TexCoord[1].st);

                // Filter alpha map according to the threshold
                if(alpha_color.r < threshold
                && alpha_color.g < threshold
                && alpha_color.b < threshold)
                    discard;

                // Get color map
                vec4 mainColor = texture2D(colorMap, gl_TexCoord[0].xy);

                // Check if there is really a color map
                if(hasColorMap)
                    mainColor *= color;
                else
                    mainColor  = color;

                gl_FragColor = mainColor;
            }
        >>
    shader_set colorMap    := 0               // Unit of the color map
    shader_set alphaMap    := 1               // Unit of the alpha map
    shader_set threshold   := ALPHA_THRESHOLD // Threshold of the mapping
    shader_set hasColorMap := HAS_COLOR_MAP   // Check if there is a color map

// -------------------------------------------------------------------------------------------------------------------
//   DISPLACEMENT MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Displacement_mapping
//   or http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter08.html
// -------------------------------------------------------------------------------------------------------------------

// Define displacement ratio
DISPLACEMENT_RATIO -> 0.0
DISPLACEMENT_RATIO := 0.0

displacement_mapping ratio:real ->
    /**
    * Apply displacement mapping.
    **/
    has_color_map
    enable_pixel_blur
    DISPLACEMENT_RATIO := ratio
    if SHADER4_AVAILABLE_MAPPING = false then
        displacement_shader_no_lights
    else
        displacement_shader_lights


displacement_shader_lights ->
    /**
    * Define displacement shader with a full support of lights.
    **/
    shader_program
        shader_log
        vertex_shader <<
            // Mapping paramaters
            uniform float     ratio;
            uniform sampler2D displacementMap;

            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            void main()
            {
               vec4 newPos, dv;
               float df;

               // Compute texture coordinates
               gl_TexCoord[0] = gl_TextureMatrix[0] *  gl_MultiTexCoord0;
               gl_TexCoord[1] = gl_TextureMatrix[1] *  gl_MultiTexCoord1;
               gl_TexCoord[2] = gl_TextureMatrix[2] *  gl_MultiTexCoord2;

               // Calculate new vertex position according to its normal and its texture coordinates
               dv     = texture2D( displacementMap, gl_TexCoord[1].st );
               df     = 0.30 * dv.x + 0.59 * dv.y + 0.11 * dv.z;
               newPos = vec4(df * ratio * gl_Normal, 0.0) + gl_Vertex;

               // Compute position
               gl_Position = gl_ModelViewProjectionMatrix * newPos;

               // Compute world position and normal
               normal  = gl_NormalMatrix * gl_Normal;
               viewDir = -vec3(gl_ModelViewMatrix * gl_Vertex);

               color = gl_Color;
            }
        >>
        fragment_shader <<
            #extension GL_EXT_gpu_shader4 : require

            uniform int       lights;
            uniform bool      hasColorMap;
            uniform sampler2D colorMap;
            uniform sampler2D normalMap;

            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;

            /**
            * Calculate tangent space matrix from normal, vector in plane
            * and texture coordinates.
            **/
            mat3 computeTangentFrame(vec3 normal, vec3 position, vec2 texCoord)
            {
                // Compute derivatives
                vec3 dpx = dFdx(position);
                vec3 dpy = dFdy(position);
                vec2 dtx = dFdx(texCoord);
                vec2 dty = dFdy(texCoord);

                // Compute tangent and binormal
                vec3 tangent  = normalize(dpy * dtx.t - dpx * dty.t);
                vec3 binormal = cross(tangent, normal);

                return mat3(tangent, binormal, normal);
            }

            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene.
            **/
            vec4 computeRenderColor(vec4 renderColor)
            {
                vec4 lighting_color = renderColor;
                if(lights > 0)
                {
                    // Define a maximum of lights supported
                    int MAX_LIGHTS = 8;

                    // Normalize vectors
                    vec3 N = normalize(normal);
                    vec3 V = normalize(viewDir);

                    // Compute bump coefficient according to normal map
                    vec3 bump = normalize(texture2D(normalMap, gl_TexCoord[2].st).xyz * 2.0 - 1.0);

                    // Calculate tangent space matrix
                    mat3 TBN = computeTangentFrame(N, V, gl_TexCoord[2].st);

                    // Define new normal
                    N = TBN * bump;

                    vec4 ambient  = vec4(0.0);
                    vec4 diffuse  = vec4(0.0);
                    vec4 specular = vec4(0.0);
                    ambient = gl_FrontLightModelProduct.sceneColor
                            * gl_FrontMaterial.ambient;

                    // Compute render for each enabled lights
                    for(int i = 0; i < MAX_LIGHTS; i++)
                    {
                        if(bool(lights & (1 << i)))
                        {
                            vec3 L = normalize(gl_LightSource[i].position.xyz);

                            // Compute ambient part
                            ambient += gl_LightSource[i].ambient * gl_FrontMaterial.ambient;

                            // Diffuse coefficient
                            float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                            if (nDotL > 0.0)
                            {
                                // Compute diffuse part
                                diffuse += gl_LightSource[i].diffuse
                                         * gl_FrontMaterial.diffuse
                                         * nDotL;

                                // Compute specular coefficient
                                float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                                if (nDotV > 0.0)
                                {
                                    // Compute specular part
                                    specular += gl_LightSource[i].specular
                                              * gl_FrontMaterial.specular
                                              * pow(nDotV, gl_FrontMaterial.shininess);
                                }
                            }
                        }
                    }

                     // Define new render color
                    lighting_color = (ambient + diffuse) * renderColor + specular;
                }

                return lighting_color;
            }

            void main()
            {
                // Get color map
                vec4 mainColor = texture2D(colorMap, gl_TexCoord[0].xy);

                // Check if there is really a color map
                if(hasColorMap)
                    mainColor *= color;
                else
                    mainColor  = color;

                gl_FragColor = computeRenderColor(mainColor);
            }
        >>
    shader_set colorMap        := 0                  // Unit of the color map
    shader_set displacementMap := 1                  // Unit of the displacement map
    shader_set normalMap       := 2                  // Unit of the normal map
    shader_set ratio           := DISPLACEMENT_RATIO // Ratio of the displacement
    shader_set lights          := lights_mask        // Bitmask of all enabled lights
    shader_set hasColorMap     := HAS_COLOR_MAP      // Check if there is a color map


displacement_shader_no_lights ->
    /**
    * Define displacement shader with no lights supported.
    * This is needed in case where GL_EXT_gpu_shader4 is not available.
    **/
    shader_program
        shader_log
        vertex_shader <<
            // Mapping paramaters
            uniform float     ratio;
            uniform sampler2D displacementMap;

            varying vec4 color;
            void main()
            {
               vec4 newPos, dv;
               float df;

               // Compute texture coordinates
               gl_TexCoord[0] = gl_TextureMatrix[0] *  gl_MultiTexCoord0;
               gl_TexCoord[1] = gl_TextureMatrix[1] *  gl_MultiTexCoord1;

               // Calculate new vertex position according to its normal and its texture coordinates
               dv     = texture2D( displacementMap, gl_TexCoord[1].st );
               df     = 0.30 * dv.x + 0.59 * dv.y + 0.11 * dv.z;
               newPos = vec4(df * ratio * gl_Normal, 0.0) + gl_Vertex;

               // Compute position
               gl_Position = gl_ModelViewProjectionMatrix * newPos;

               color = gl_Color;
            }
        >>
        fragment_shader <<
            uniform bool      hasColorMap;
            uniform sampler2D colorMap;

            varying vec4 color;
            void main()
            {
               // Get color map
               vec4 mainColor = texture2D(colorMap, gl_TexCoord[0].xy);

               // Check if there is really a color map
               if(hasColorMap)
                   mainColor *= color;
               else
                   mainColor  = color;

               gl_FragColor = mainColor;
            }
        >>
    shader_set colorMap        := 0                  // Unit of the color map
    shader_set displacementMap := 1                  // Unit of the displacement map
    shader_set ratio           := DISPLACEMENT_RATIO // Ratio of the displacement
    shader_set hasColorMap     := HAS_COLOR_MAP      // Check if there is a color map

// -------------------------------------------------------------------------------------------------------------------
//   NORMAL MAP
// -------------------------------------------------------------------------------------------------------------------

normal_map ->
    /**
    * Convert the current texture into a basic normal map.
    **/
    enable_pixel_blur
    CODE -> normal_map_shader
    TEXTURE_WIDTH := texture_width
    TEXTURE_HEIGHT := texture_height
    TEXTURE_ID := texture
    frame_texture TEXTURE_WIDTH, TEXTURE_HEIGHT,
        color "white"
        texture TEXTURE_ID
        normal_map_shader
        rectangle 0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT


normal_map_shader ->
    /**
    * Define normal map shader.
    **/
    shader_program
        vertex_shader <<
            void main()
            {
                // Compute position
                gl_Position = ftransform();

                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
            }
        >>
        fragment_shader <<
            uniform float     width;
            uniform float     height;
            uniform sampler2D colorMap;

            void main()
            {
                float strength  = 12.0;

                // Size of a pixel
                float pixel_w = 1.0 / width;
                float pixel_h = 1.0 / height;

                // Compute offset
                vec2 offset[8];
                offset[0] = vec2(-pixel_w, -pixel_h);
                offset[1] = vec2(-pixel_w, 0.0);
                offset[2] = vec2(-pixel_w, pixel_h);

                offset[3] = vec2(0.0, -pixel_h);
                offset[4] = vec2(0.0, pixel_h);
                offset[5] = vec2(pixel_w, -pixel_h);

                offset[6] = vec2(pixel_w, 0.0);
                offset[7] = vec2(pixel_w, pixel_h);

                float tl = abs(texture2D(colorMap, gl_TexCoord[0].st + offset[0]).x);   // top left
                float  l = abs(texture2D(colorMap, gl_TexCoord[0].st + offset[1]).x);   // left
                float bl = abs(texture2D(colorMap, gl_TexCoord[0].st + offset[2]).x);   // bottom left

                float  t = abs(texture2D(colorMap, gl_TexCoord[0].st + offset[3]).x);   // top
                float  b = abs(texture2D(colorMap, gl_TexCoord[0].st + offset[4]).x);   // bottom
                float tr = abs(texture2D(colorMap, gl_TexCoord[0].st + offset[5]).x);   // top right

                float  r = abs(texture2D(colorMap, gl_TexCoord[0].st + offset[6]).x);   // right
                float br = abs(texture2D(colorMap, gl_TexCoord[0].st + offset[7]).x);   // bottom right

                // Compute dx using Sobel:
                //           -1 0 1
                //           -2 0 2
                //           -1 0 1
                float dX = tr + 2.0 * r + br -tl - 2.0 * l - bl;

                // Compute dy using Sobel:
                //           -1 -2 -1
                //            0  0  0
                //            1  2  1
                float dY = bl + 2.0 * b + br -tl - 2.0 * t - tr;

                vec4 normal = vec4(normalize(vec3(dX, 1.0 / strength, dY)), 1.0) * 0.3 + 0.4;
                gl_FragColor = normal + vec4(0.0, 0.0, 0.8, 1.0);
            }
        >>
    shader_set colorMap := texture_unit   // Unit of the texture to filter
    shader_set width    := TEXTURE_WIDTH  // Width of the color map
    shader_set height   := TEXTURE_HEIGHT // Height of the color map

// -------------------------------------------------------------------------------------------------------------------
//   NORMAL MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Normal_mapping
// -------------------------------------------------------------------------------------------------------------------

normal_mapping ->
    /**
    * Apply normal mapping.
    **/
    has_color_map
    enable_pixel_blur
    if SHADER4_AVAILABLE_MAPPING = false then
        normal_shader_no_lights
    else
        normal_shader_lights

normal_shader_lights ->
    /**
    * Define normal shader with a full support of lights.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            void main()
            {
                // Determine object parameters
                gl_Position    = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;

                // Compute world position and normal
                normal  = gl_NormalMatrix * gl_Normal;
                viewDir = -vec3(gl_ModelViewMatrix * gl_Vertex);

                color = gl_Color;
            }
        >>
        fragment_shader <<
             #extension GL_EXT_gpu_shader4 : require

            // Mapping paramaters
            uniform sampler2D colorMap;
            uniform sampler2D normalMap;
            uniform int       lights;
            uniform bool      hasColorMap;

            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            /**
            * Calculate tangent space matrix from normal, vector in plane
            * and texture coordinates.
            **/
            mat3 computeTangentFrame(vec3 normal, vec3 position, vec2 texCoord)
            {
                // Compute derivatives
                vec3 dpx = dFdx(position);
                vec3 dpy = dFdy(position);
                vec2 dtx = dFdx(texCoord);
                vec2 dty = dFdy(texCoord);

                // Compute tangent and binormal
                vec3 tangent  = normalize(dpy * dtx.t - dpx * dty.t);
                vec3 binormal = cross(tangent, normal);

                return mat3(tangent, binormal, normal);
            }

            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene.
            **/
            vec4 computeRenderColor(vec3 N, vec3 V, vec4 renderColor)
            {
                vec4 lighting_color;
                if(lights > 0)
                {
                    // Define a maximum of lights supported
                    int MAX_LIGHTS = 8;

                    vec4 ambient  = vec4(0.0);
                    vec4 diffuse  = vec4(0.0);
                    vec4 specular = vec4(0.0);
                    ambient  = gl_FrontLightModelProduct.sceneColor
                             * gl_FrontMaterial.ambient;

                    // Compute render for each enabled lights
                    for(int i = 0; i < MAX_LIGHTS; i++)
                    {
                        if(bool(lights & (1 << i)))
                        {
                            vec3 L = normalize(gl_LightSource[i].position.xyz);

                            // Compute ambient part
                            ambient += gl_LightSource[i].ambient
                                     * gl_FrontMaterial.ambient;

                            // Diffuse coefficient
                            float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                            if (nDotL > 0.0)
                            {
                                // Compute diffuse part
                                diffuse += gl_LightSource[i].diffuse * gl_FrontMaterial.diffuse * nDotL;

                                // Compute specular coefficient
                                float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                                if (nDotV > 0.0)
                                {
                                    // Compute specular part
                                    specular += gl_LightSource[i].specular
                                              * gl_FrontMaterial.specular
                                              * pow(nDotV, gl_FrontMaterial.shininess);
                                }
                            }
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;
                }
                else
                {
                    // In case where there is no light, we define a unique light
                    // with a simple material to increse the render of this mapping
                    vec4 ambient  = vec4(0.0);
                    vec4 diffuse  = vec4(0.0);
                    vec4 specular = vec4(0.0);

                    vec3 L = normalize(vec3(0.0, 0.0, 50));

                    // Compute ambient part
                    ambient = vec4(0.0, 0.0, 0.0, 1.0);

                    // Diffuse coefficient
                    float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                    if (nDotL > 0.0)
                    {
                        // Compute diffuse part
                        diffuse = vec4(1.0, 1.0, 1.0, 1.0) * nDotL;

                        // Compute specular coefficient
                        float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                        if (nDotV > 0.0)
                        {
                            // Compute specular part
                            specular += vec4(0.3, 0.3, 0.3, 1.0) * pow(nDotV, 70.0);
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;
                }

                return lighting_color;
            }

            void main()
            {
                // Normalize vectors
                vec3 n = normalize(normal);
                vec3 v = normalize(viewDir);

                // Compute bump coefficient according to normal map
                vec3 bump = normalize(texture2D(normalMap, gl_TexCoord[1].st).xyz * 2.0 - 1.0);

                // Calculate tangent space matrix
                mat3 TBN = computeTangentFrame(n, v, gl_TexCoord[1].st);

                // Define new normal
                n = TBN * bump;

                // Get color map
                vec4 renderColor = texture2D(colorMap, gl_TexCoord[0].st);

                // Check if there is really a color map
                if(hasColorMap)
                    renderColor *= color;
                else
                    renderColor  = color;

                gl_FragColor = computeRenderColor(n, v, renderColor);
            }
        >>
    shader_set colorMap    := 0             // Unit of the color map
    shader_set normalMap   := 1             // Unit of the normal map
    shader_set lights      := lights_mask   // Bitmask with enabled lights
    shader_set hasColorMap := HAS_COLOR_MAP // Check if a color map is bound


normal_shader_no_lights ->
    /**
    * Define normal shader with no support of lights.
    * This is needed in case where GL_EXT_gpu_shader4 is not available.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            void main()
            {
                // Determine object parameters
                gl_Position    = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;

                // Compute world position and normal
                normal  = gl_NormalMatrix * gl_Normal;
                viewDir = -vec3(gl_ModelViewMatrix * gl_Vertex);

                color = gl_Color;
            }
        >>
        fragment_shader <<
            // Mapping paramaters
            uniform bool      hasColorMap;
            uniform sampler2D colorMap;
            uniform sampler2D normalMap;

            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            /**
            * Calculate tangent space matrix from normal, vector in plane
            * and texture coordinates.
            **/
            mat3 computeTangentFrame(vec3 normal, vec3 position, vec2 texCoord)
            {
                // Compute derivatives
                vec3 dpx = dFdx(position);
                vec3 dpy = dFdy(position);
                vec2 dtx = dFdx(texCoord);
                vec2 dty = dFdy(texCoord);

                // Compute tangent and binormal
                vec3 tangent  = normalize(dpy * dtx.t - dpx * dty.t);
                vec3 binormal = cross(tangent, normal);

                return mat3(tangent, binormal, normal);
            }

            /**
            * Compute render color according to materials, lights and colors parameters
            * which are set in the current scene.
            **/
            vec4 computeRenderColor(vec3 N, vec3 V, vec4 renderColor)
            {
                vec4 lighting_color;

                // In case where there is no light, we define a unique light
                // with a simple material to increse the render of this mapping
                vec4 ambient  = vec4(0.0);
                vec4 diffuse  = vec4(0.0);
                vec4 specular = vec4(0.0);

                vec3 L = normalize(vec3(0.0, 0.0, 50));

                // Compute ambient part
                ambient = vec4(0.0, 0.0, 0.0, 1.0);

                // Diffuse coefficient
                float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                if (nDotL > 0.0)
                {
                    // Compute diffuse part
                    diffuse = vec4(1.0, 1.0, 1.0, 1.0) * nDotL;

                    // Compute specular coefficient
                    float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                    if (nDotV > 0.0)
                    {
                        // Compute specular part
                        specular += vec4(0.3, 0.3, 0.3, 1.0) * pow(nDotV, 70.0);
                    }
                }

                 // Define new render color
                lighting_color  = (ambient + diffuse) * renderColor + specular;
                return lighting_color;
            }

            void main()
            {
                // Normalize vectors
                vec3 n = normalize(normal);
                vec3 v = normalize(viewDir);

                // Compute bump coefficient according to normal map
                vec3 bump = normalize(texture2D(normalMap, gl_TexCoord[1].st).xyz * 2.0 - 1.0);

                // Calculate tangent space matrix
                mat3 TBN = computeTangentFrame(n, v, gl_TexCoord[1].st);

                // Define new normal
                n = TBN * bump;

                // Get color map
                vec4 renderColor = texture2D(colorMap, gl_TexCoord[0].st);

                // Check if there is really a color map
                if(hasColorMap)
                    renderColor *= color;
                else
                    renderColor  = color;
                gl_FragColor = computeRenderColor(n, v, renderColor);
            }
        >>
    shader_set colorMap    := 0             // Unit of the color map
    shader_set normalMap   := 1             // Unit of the normal map
    shader_set hasColorMap := HAS_COLOR_MAP // Check if a color map is bound

// -------------------------------------------------------------------------------------------------------------------
//   NOISE MAP
// -------------------------------------------------------------------------------------------------------------------

NOISE_SEED -> 0
NOISE_SEED := 0

noise_map w:integer, h:integer, s:integer ->
    /**
    * Generate a random noise image.
    **/
    enable_pixel_blur
    frame_texture w, h,
        color "white"
        NOISE_SEED := s
        generate_noise
        rectangle 0, 0, w, h

generate_noise ->
    /**
    * Generate noise effect.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec4 color;
            void main()
            {
               gl_TexCoord[0] = gl_Vertex;
               gl_Position    = ftransform();

               color = gl_Color;
            }
        >>
        fragment_shader <<
            #extension GL_EXT_gpu_shader4 : require
            uniform int seed;

            varying vec4 color;
            // Pseudo random number base generator use to make noise
            float noise(vec2 v)
            {
                int n;
                n = int(v.x * 40.0 + v.y * 6400.0);
                n = (n << 13) ^ n;

                return float( (n * (n * n * 15731 * seed + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0;
            }

            void main()
            {
                float noiseColor = (noise(gl_TexCoord[0].st)) * 0.5;
                gl_FragColor     = vec4(noiseColor, noiseColor, noiseColor, 1.0) * color;
            }
        >>
    shader_set seed := NOISE_SEED // Distribution of the noise

// -------------------------------------------------------------------------------------------------------------------
//   NOISE MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Image_noise
// -------------------------------------------------------------------------------------------------------------------

// Define noise ratio
NOISE_RATIO -> 0.0
NOISE_RATIO := 0.0

noise_mapping n->
    /**
    * Apply noise mapping.
    **/
    NOISE_RATIO := n
    enable_pixel_blur
    if SHADER4_AVAILABLE_MAPPING = false then
        noise_shader_no_lights
    else
        noise_shader_lights

noise_shader_lights ->
    /**
    * Define noise shader with a full support of lights.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            void main()
            {
                // Compute position
                gl_Position    = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;
                gl_TexCoord[2] = gl_TextureMatrix[2] * gl_MultiTexCoord2;

                // Compute world position and normal
                normal  = gl_NormalMatrix * gl_Normal;
                viewDir = -vec3(gl_ModelViewMatrix * gl_Vertex);

                color = gl_Color;
            }
        >>
        fragment_shader <<
            #extension GL_EXT_gpu_shader4 : require

            // Mapping parameters
            uniform float     ratio;
            uniform sampler2D colorMap;
            uniform sampler2D noiseMap;
            uniform sampler3D noiseMap3D;
            uniform int lights;

            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene.
            **/
            vec4 computeRenderColor(vec4 renderColor)
            {
                vec4 lighting_color = renderColor;
                if(lights > 0)
                {
                    // Define a maximum of lights supported
                    int MAX_LIGHTS = 8;

                    vec3 N = normalize(normal);
                    vec3 V = normalize(viewDir);

                    vec4 ambient  = vec4(0.0);
                    vec4 diffuse  = vec4(0.0);
                    vec4 specular = vec4(0.0);
                    ambient = gl_FrontLightModelProduct.sceneColor
                            * gl_FrontMaterial.ambient;

                    for(int i = 0; i < MAX_LIGHTS; i++)
                    {
                        if(bool(lights & (1 << i)))
                        {
                            vec3 L = normalize(gl_LightSource[i].position.xyz);

                            // Compute ambient part
                            ambient += gl_LightSource[i].ambient
                                     * gl_FrontMaterial.ambient;

                            // Diffuse coefficient
                            float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                            if (nDotL > 0.0)
                            {
                                // Compute diffuse part
                                diffuse += gl_LightSource[i].diffuse
                                         * gl_FrontMaterial.diffuse
                                         * nDotL;

                                // Compute specular coefficient
                                float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                                if (nDotV > 0.0)
                                {
                                    // Compute specular part
                                    specular += gl_LightSource[i].specular
                                              * gl_FrontMaterial.specular
                                              * pow(nDotV, gl_FrontMaterial.shininess);
                                }
                            }
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;
                }

                return lighting_color;
            }

            void main()
            {
                // Get noise value from noise map.
                vec4 noise = texture3D(noiseMap3D, gl_TexCoord[2].xyz );

                if(noise.r == 0.0 && noise.g == 0.0 && noise.b == 0.0)
                    noise = texture2D(noiseMap, gl_TexCoord[1].xy );

                // Compute noise coordinates
                vec2 noiseCoord = gl_TexCoord[0].st + vec2( noise.r * 0.065, -noise.g * 0.025 ) *  ratio / 10.0;

                vec4 renderColor = texture2D(colorMap, noiseCoord) * color;

                gl_FragColor = computeRenderColor(renderColor);
            }
        >>
    shader_set colorMap   := 0           // Unit of the color map
    shader_set noiseMap   := 1           // Unit of the noise map 2D
    shader_set noiseMap3D := 2           // Unit of the noise map 3D
    shader_set ratio      := NOISE_RATIO // Ratio of noise
    shader_set lights     := lights_mask // Bitmask of all enabled lights


noise_shader_no_lights ->
    /**
    * Define noise shader with no lights supported.
    * This is needed in case where GL_EXT_gpu_shader4 is not available.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec4 color;
            void main()
            {
                // Compute position
                gl_Position    = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;

                color = gl_Color;
            }
        >>
        fragment_shader <<
            // Mapping parameters
            uniform float     ratio;
            uniform sampler2D colorMap;
            uniform sampler2D noiseMap;
            uniform sampler3D noiseMap3D;

            varying vec4 color;
            void main()
            {
                // Get noise value from noise map.
                vec4 noise = texture2D(noiseMap, gl_TexCoord[1].st );

                if(noise.r == 0.0 && noise.g == 0.0 && noise.b == 0.0)
                    noise = texture3D(noiseMap3D, gl_TexCoord[1].str );

                // Compute noise coordinates
                vec2 noiseCoord = gl_TexCoord[0].st + vec2( noise.r * 0.065, -noise.g * 0.025 ) *  ratio / 10.0;

                // Apply noise coordinates to color map
                gl_FragColor = texture2D(colorMap, noiseCoord ) * color;
            }
        >>
    shader_set colorMap   := 0            // Unit of the color map
    shader_set noiseMap   := 1            // Unit of the noise map 2D
    shader_set noiseMap3D := 1            // Unit of the noise map 3D
    shader_set ratio      := NOISE_RATIO  // Ratio of noise

// -------------------------------------------------------------------------------------------------------------------
//   CUBE MAP
//   For further informations, see http://wiki.polycount.com/CubeMap
// -------------------------------------------------------------------------------------------------------------------

cube_map s:integer, t:tree->
    /**
    * Create a cube map.
    **/
    enable_pixel_blur
    if SHADER4_AVAILABLE_MAPPING = false then
        cube_map_shader_no_lights
    else
        cube_map_shader_lights
    texture_cube s, t


cube_map_shader_lights ->
    /**
    * Define shader to apply correctly cube map with a full support of lights.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            void main()
            {
                // Generate texture coordinates (equivalent to glTexGen)
                vec4 xPlane = vec4( 1.0, 0.0, 0.0, 0.0 );
                vec4 yPlane = vec4( 0.0, 1.0, 0.0, 0.0 );
                vec4 zPlane = vec4( 0.0, 0.0, 1.0, 0.0 );

                gl_TexCoord[0].x = dot(gl_TextureMatrix[0] * vec4(gl_Vertex.xyz, 1.0), xPlane);
                gl_TexCoord[0].y = dot(gl_TextureMatrix[0] * vec4(gl_Vertex.xyz, 1.0), yPlane);
                gl_TexCoord[0].z = dot(gl_TextureMatrix[0] * vec4(gl_Vertex.xyz, 1.0), zPlane);

                // Compute position
                gl_Position = ftransform();

                // Compute world position and normal
                normal  = gl_NormalMatrix * gl_Normal;
                viewDir = -vec3(gl_ModelViewMatrix * gl_Vertex);

                color = gl_Color;
            }
        >>
        fragment_shader <<
            #extension GL_EXT_gpu_shader4 : require

            // Mapping parameters
            uniform samplerCube cubeMap;
            uniform int lights;

            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene.
            **/
            vec4 computeRenderColor(vec4 renderColor)
            {
                vec4 lighting_color = renderColor;
                if(lights > 0)
                {
                    // Define a maximum of lights supported
                    int MAX_LIGHTS = 8;

                    vec3 N = normalize(normal);
                    vec3 V = normalize(viewDir);

                    vec4 ambient  = vec4(0.0);
                    vec4 diffuse  = vec4(0.0);
                    vec4 specular = vec4(0.0);
                    ambient = gl_FrontLightModelProduct.sceneColor
                            * gl_FrontMaterial.ambient;

                    for(int i = 0; i < MAX_LIGHTS; i++)
                    {
                        if(bool(lights & (1 << i)))
                        {
                            vec3 L = normalize(gl_LightSource[i].position.xyz);

                            // Compute ambient part
                            ambient += gl_LightSource[i].ambient * gl_FrontMaterial.ambient;

                            // Diffuse coefficient
                            float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                            if (nDotL > 0.0)
                            {
                                // Compute diffuse part
                                diffuse += gl_LightSource[i].diffuse
                                         * gl_FrontMaterial.diffuse
                                         * nDotL;

                                // Compute specular coefficient
                                float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                                if (nDotV > 0.0)
                                {
                                    // Compute specular part
                                    specular += gl_LightSource[i].specular
                                              * gl_FrontMaterial.specular
                                              * pow(nDotV, gl_FrontMaterial.shininess);
                                }
                            }
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;
                }

                return lighting_color;
            }

            void main()
            {
                vec4 renderColor = textureCube(cubeMap, gl_TexCoord[0].xyz) * color;
                gl_FragColor     = computeRenderColor(renderColor);
            }
        >>
    shader_set cubeMap := texture_unit // Unit of the cube map
    shader_set lights  := lights_mask  // Bitmask of all enabled lights


cube_map_shader_no_lights ->
    /**
    * Define shader to apply correctly cube map with no lights supported.
    * This is needed in case where GL_EXT_gpu_shader4 is not available.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec4 color;

            void main()
            {
                // Generate texture coordinates (equivalent to glTexGen)
                vec4 xPlane = vec4( 1.0, 0.0, 0.0, 0.0 );
                vec4 yPlane = vec4( 0.0, 1.0, 0.0, 0.0 );
                vec4 zPlane = vec4( 0.0, 0.0, 1.0, 0.0 );

                gl_TexCoord[0].x = dot(gl_TextureMatrix[0] * vec4(gl_Vertex.xyz, 1.0), xPlane);
                gl_TexCoord[0].y = dot(gl_TextureMatrix[0] * vec4(gl_Vertex.xyz, 1.0), yPlane);
                gl_TexCoord[0].z = dot(gl_TextureMatrix[0] * vec4(gl_Vertex.xyz, 1.0), zPlane);

                // Compute position
                gl_Position = ftransform();

                color = gl_Color;
            }
        >>
        fragment_shader <<
            varying vec4 color;

            // Mapping parameters
            uniform samplerCube cubeMap;
            void main()
            {
                vec4 cubeColor = textureCube(cubeMap, gl_TexCoord[0].xyz);
                gl_FragColor   = cubeColor * color;
            }
        >>
    shader_set cubeMap := texture_unit // Unit of the cube map

// -------------------------------------------------------------------------------------------------------------------
//   CUBE MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Cube_mapping
// -------------------------------------------------------------------------------------------------------------------

// Define cube mapping ratio
CUBE_RATIO -> 0.0
CUBE_RATIO := 0.0

cube_mapping r:real->
    /**
    * Apply cube mapping.
    **/
    has_color_map
    enable_pixel_blur
    CUBE_RATIO := r
    if SHADER4_AVAILABLE_MAPPING = false then
        cube_shader_no_lights
    else
        cube_shader_lights

cube_shader_lights ->
    /**
    * Define cube mapping shader with a full support of lights.
    **/
    shader_program
        shader_log
        vertex_shader <<
            uniform mat3 normalMatrix;
            uniform vec3 camera;

            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            void main()
            {
                // Compute world position and normal
                vec4 worldPos = gl_Vertex;
                viewDir  = normalize(worldPos.xyz - camera);
                normal   = normalize(normalMatrix * gl_Normal);

                // Compute reflection vector
                vec3 r = reflect (viewDir, normal);

                // Compute texture coordinates
                gl_TexCoord[1] = gl_TextureMatrix[1] * vec4 (r, 1.0);
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;

                // Compute position
                gl_Position = ftransform();

                // Compute new values for lighting
                normal   =  normalize(gl_NormalMatrix * gl_Normal);
                viewDir  = -normalize((gl_ModelViewMatrix * gl_Vertex).xyz);

                color = gl_Color;
            }
        >>
        fragment_shader <<
            #extension GL_EXT_gpu_shader4 : require

            // Mapping parameters
            uniform float       ratio;
            uniform sampler2D   colorMap;
            uniform samplerCube cubeMap;
            uniform int         lights;
            uniform bool        hasColorMap;

            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            /**
            * Compute render color according to materials,
            * lights and colors parameters which are
            * set in the current scene.
            **/
            vec4 computeRenderColor(vec4 renderColor)
            {
                vec4 lighting_color = renderColor;
                if(lights > 0)
                {
                    // Define a maximum of lights supported
                    int MAX_LIGHTS = 8;

                    vec3 N = normalize(normal);
                    vec3 V = normalize(viewDir);

                    vec4 ambient  = vec4(0.0);
                    vec4 diffuse  = vec4(0.0);
                    vec4 specular = vec4(0.0);
                    ambient = gl_FrontLightModelProduct.sceneColor
                            * gl_FrontMaterial.ambient;

                    for(int i = 0; i < MAX_LIGHTS; i++)
                    {
                        if(bool(lights & (1 << i)))
                        {
                            vec3 L = normalize(gl_LightSource[i].position.xyz);

                            // Compute ambient part
                            ambient += gl_LightSource[i].ambient * gl_FrontMaterial.ambient;

                            // Diffuse coefficient
                            float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                            if (nDotL > 0.0)
                            {
                                // Compute diffuse part
                                diffuse += gl_LightSource[i].diffuse
                                         * gl_FrontMaterial.diffuse
                                         * nDotL;

                                // Compute specular coefficient
                                float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                                if (nDotV > 0.0)
                                {
                                    // Compute specular part
                                    specular += gl_LightSource[i].specular
                                              * gl_FrontMaterial.specular
                                              * pow(nDotV, gl_FrontMaterial.shininess);
                                }
                            }
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;
                }

                return lighting_color;
            }

            void main()
            {
                vec4 cubeColor, mainColor, renderColor;

                // Get cube map
                cubeColor = textureCube(cubeMap, gl_TexCoord[1].xyz);

                // Get color map
                mainColor = texture2D(colorMap, gl_TexCoord[0].st);

                // Check if there is really a color map
                if(hasColorMap)
                   mainColor *= color;
                else
                   mainColor  = color;

                renderColor  = mix(mainColor, cubeColor, ratio);
                gl_FragColor = computeRenderColor(renderColor);
            }
        >>
    shader_set colorMap    := 0             // Unit of the color map
    shader_set cubeMap     := 1             // Unit of the cube map
    shader_set lights      := lights_mask   // Bitmask of enabled lights
    shader_set ratio       := CUBE_RATIO    // Reflection ratio
    shader_set hasColorMap := HAS_COLOR_MAP // Check if a color map is bound

    //FOLLOWING PARAMETERS ARE NEEDED BUT NOT OPTIMIZED BECAUSE LISTS ARE RELOAD FULLY TO EACH XL FUNCTIONS CALL
    shader_set camera       := (camera_position at 1; camera_position at 2; camera_position at 3)
    shader_set normalMatrix := (model_matrix at 1;  model_matrix at 2;  model_matrix at 3;
                                model_matrix at 5;  model_matrix at 6;  model_matrix at 7;
                                model_matrix at 9;  model_matrix at 10; model_matrix at 11)


cube_shader_no_lights ->
    /**
    * Define cube mapping shader with no lights supported.
    * This is needed in case where GL_EXT_gpu_shader4 is not available.
    **/
    shader_program
        shader_log
        vertex_shader <<
            uniform mat3 normalMatrix;
            uniform vec3 camera;

            varying vec4 color;
            void main()
            {
                // Compute world position and normal
                vec4 worldPos = gl_Vertex;
                vec3 normal   = normalize(normalMatrix * gl_Normal);
                vec3 eyePos   = normalize(worldPos.xyz - camera);

                // Compute reflection vector
                vec3 r = reflect (eyePos, normal);

                // Compute texture coordinates
                gl_TexCoord[1] = gl_TextureMatrix[1] * vec4 (r, 1.0);
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;

                // Compute position
                gl_Position = ftransform();

                color = gl_Color;
            }
        >>
        fragment_shader <<
            // Mapping parameters
            uniform bool        hasColorMap;
            uniform float       ratio;
            uniform sampler2D   colorMap;
            uniform samplerCube cubeMap;

            varying vec4 color;
            void main()
            {
                vec4 cubeColor, mainColor, renderColor;

                // Get cube map
                cubeColor = textureCube(cubeMap, gl_TexCoord[1].xyz);

                // Get color map
                mainColor = texture2D(colorMap, gl_TexCoord[0].st);

                // Check if there is really a color map
                if(hasColorMap)
                   mainColor *= color;
                else
                   mainColor  = color;

                renderColor  = mix(mainColor, cubeColor, ratio);
                gl_FragColor = renderColor;
            }
        >>
    shader_set colorMap    := 0             // Unit of the color map
    shader_set cubeMap     := 1             // Unit of the cube map
    shader_set ratio       := CUBE_RATIO    // Reflection ratio
    shader_set hasColorMap := HAS_COLOR_MAP // Check if a color map is bound

    //FOLLOWING PARAMETERS ARE NEEDED BUT NOT OPTIMIZED BECAUSE LISTS ARE RELOAD FULLY TO EACH XL FUNCTIONS CALL
    shader_set camera       := (camera_position at 1; camera_position at 2; camera_position at 3)
    shader_set normalMatrix := (model_matrix at 1;  model_matrix at 2;  model_matrix at 3;
                                model_matrix at 5;  model_matrix at 6;  model_matrix at 7;
                                model_matrix at 9;  model_matrix at 10; model_matrix at 11)

// -------------------------------------------------------------------------------------------------------------------
//   SPHERE MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Sphere_mapping
// -------------------------------------------------------------------------------------------------------------------

// Define sphere mapping ratio
SPHERE_RATIO -> 0.0
SPHERE_RATIO := 0.0

sphere_mapping r:real->
    /**
    * Apply sphere mapping.
    **/
    has_color_map
    enable_pixel_blur
    SPHERE_RATIO := r
    if SHADER4_AVAILABLE_MAPPING = false then
        sphere_shader_no_lights
    else
        sphere_shader_lights


sphere_shader_lights ->
    /**
    * Define sphere mapping shader with a full support of lights.
    **/
    shader_program
        vertex_shader <<
        uniform mat4 model;
        uniform vec3 camera;

        varying vec3 viewDir;
        varying vec3 normal;
        varying vec4 color;
        void main()
        {
            mat3 normalMatrix;

            // Get linear part of model matrix
            normalMatrix[0][0] = model[0][0];
            normalMatrix[0][1] = model[0][1];
            normalMatrix[0][2] = model[0][2];

            normalMatrix[1][0] = model[1][0];
            normalMatrix[1][1] = model[1][1];
            normalMatrix[1][2] = model[1][2];

            normalMatrix[2][0] = model[2][0];
            normalMatrix[2][1] = model[2][1];
            normalMatrix[2][2] = model[2][2];

            // Determine object parameters
            gl_Position    = ftransform();
            gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;

            // Compute world position and normal
            vec4 worldPos = model * gl_Vertex;
            viewDir  = normalize(worldPos.xyz - camera);
            normal   = normalize(normalMatrix * gl_Normal);

            // Compute camera parameters
            vec3  r  = reflect( viewDir, normal );
            float m  = 2.0 * sqrt( r.x * r.x + r.y * r.y + (r.z + 1.0) * (r.z + 1.0) );

            // Compute sphere coordinates
            gl_TexCoord[1].s = r.x/m + 0.5;
            gl_TexCoord[1].t = r.y/m + 0.5;

            // Compute new values for lighting
            normal   =  normalize(gl_NormalMatrix * gl_Normal);
            viewDir  = -normalize((gl_ModelViewMatrix * gl_Vertex).xyz);

            color = gl_Color;
        }
        >>
        fragment_shader <<
            #extension GL_EXT_gpu_shader4 : require

            // Mapping parameters
            uniform int      lights;
            uniform bool      hasColorMap;
            uniform float     ratio;
            uniform sampler2D colorMap;
            uniform sampler2D sphereMap;

            varying vec3 viewDir;
            varying vec3 normal;
            varying vec4 color;
            /**
            * Compute render color according to materials, lights and colors parameters
            * which are set in the current scene.
            **/
            vec4 computeRenderColor(vec4 renderColor)
            {
                vec4 lighting_color = renderColor;
                if(lights > 0)
                {
                    // Define a maximum of lights supported
                    int MAX_LIGHTS = 8;

                    vec3 N = normalize(normal);
                    vec3 V = normalize(viewDir);

                    vec4 ambient  = vec4(0.0);
                    vec4 diffuse  = vec4(0.0);
                    vec4 specular = vec4(0.0);
                    ambient = gl_FrontLightModelProduct.sceneColor
                            * gl_FrontMaterial.ambient;

                    for(int i = 0; i < MAX_LIGHTS; i++)
                    {
                        if(bool(lights & (1 << i)))
                        {
                            vec3 L = normalize(gl_LightSource[i].position.xyz);

                            // Compute ambient part
                            ambient += gl_LightSource[i].ambient * gl_FrontMaterial.ambient;

                            // Diffuse coefficient
                            float nDotL = max(clamp(dot(L, N), 0.0, 1.0), 0.0);
                            if (nDotL > 0.0)
                            {
                                // Compute diffuse part
                                diffuse += gl_LightSource[i].diffuse
                                         * gl_FrontMaterial.diffuse
                                         * nDotL;

                                // Compute specular coefficient
                                float nDotV = clamp(dot(reflect(-L, N), V), 0.0, 1.0);
                                if (nDotV > 0.0)
                                {
                                    // Compute specular part
                                    specular += gl_LightSource[i].specular
                                              * gl_FrontMaterial.specular
                                              * pow(nDotV, gl_FrontMaterial.shininess);
                                }
                            }
                        }
                    }

                     // Define new render color
                    lighting_color  = (ambient + diffuse) * renderColor + specular;
                }

                return lighting_color;
            }

            void main()
            {
                vec4 sphereColor, mainColor, renderColor;

                // Get sphere map
                sphereColor = texture2D(sphereMap, gl_TexCoord[1].st);

                // Get color map
                mainColor = texture2D(colorMap, gl_TexCoord[0].st);

                // Check if there is really a color map
                if(hasColorMap)
                   mainColor *= color;
                else
                   mainColor  = color;

                renderColor  = mix(mainColor, sphereColor, ratio);
                gl_FragColor = computeRenderColor(renderColor);
            }
        >>
    shader_set colorMap    := 0             // Unit of the color map
    shader_set sphereMap   := 1             // Unit of the cube map
    shader_set ratio       := SPHERE_RATIO  // Reflection ratio
    shader_set lights      := lights_mask   // Bitmask of all enabled lights
    shader_set hasColorMap := HAS_COLOR_MAP // Check if a color map is bound

    //FOLLOWING PARAMETERS ARE NEEDED BUT NOT OPTIMIZED BECAUSE LISTS ARE RELOAD FULLY TO EACH XL FUNCTIONS CALL
    shader_set camera   := (camera_position at 1; camera_position at 2; camera_position at 3)
    shader_set model    := (model_matrix at 1;  model_matrix at 2;  model_matrix at 3;  model_matrix at 4;
                            model_matrix at 5;  model_matrix at 6;  model_matrix at 7;  model_matrix at 8;
                            model_matrix at 9;  model_matrix at 10; model_matrix at 11; model_matrix at 12;
                            model_matrix at 13; model_matrix at 14; model_matrix at 15; model_matrix at 16)


sphere_shader_no_lights ->
    /**
    * Define sphere mapping shader with no lights supported.
    * This is needed in case where GL_EXT_gpu_shader4 is not available.
    **/
    shader_program
        vertex_shader <<
        uniform mat4 model;
        uniform vec3 camera;

        varying vec4 color;
        void main()
        {
            mat3 normalMatrix;

            // Get linear part of model matrix
            normalMatrix[0][0] = model[0][0];
            normalMatrix[0][1] = model[0][1];
            normalMatrix[0][2] = model[0][2];

            normalMatrix[1][0] = model[1][0];
            normalMatrix[1][1] = model[1][1];
            normalMatrix[1][2] = model[1][2];

            normalMatrix[2][0] = model[2][0];
            normalMatrix[2][1] = model[2][1];
            normalMatrix[2][2] = model[2][2];

            // Determine object parameters
            gl_Position    = ftransform();
            gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;

            // Compute world position and normal
            vec4 worldPos = model * gl_Vertex;
            vec3 normal   = normalize(normalMatrix * gl_Normal);
            vec3 eyePos   = normalize(worldPos.xyz - camera);

            // Compute camera parameters
            vec3  r  = reflect( eyePos, normal );
            float m  = 2.0 * sqrt( r.x * r.x + r.y * r.y + (r.z + 1.0) * (r.z + 1.0) );

            // Compute sphere coordinates
            gl_TexCoord[1].s = r.x/m + 0.5;
            gl_TexCoord[1].t = r.y/m + 0.5;

            color = gl_Color;
        }
        >>
        fragment_shader <<
            // Mapping parameters
            uniform bool      hasColorMap;
            uniform float     ratio;
            uniform sampler2D colorMap;
            uniform sampler2D sphereMap;

            varying vec4 color;
            void main()
            {
                vec4 sphereColor, mainColor, renderColor;

                // Get sphere map
                sphereColor = texture2D(sphereMap, gl_TexCoord[1].st);

                // Get color map
                mainColor = texture2D(colorMap, gl_TexCoord[0].st);

                // Check if there is really a color map
                if(hasColorMap)
                   mainColor *= color;
                else
                   mainColor  = color;

                renderColor  = mix(mainColor, sphereColor, ratio);
                gl_FragColor = renderColor;
            }
        >>
    shader_set colorMap    := 0             // Unit of the color map
    shader_set sphereMap   := 1             // Unit of the cube map
    shader_set ratio       := SPHERE_RATIO  // Reflection ratio
    shader_set hasColorMap := HAS_COLOR_MAP // Check if a color map is bound

    //FOLLOWING PARAMETERS ARE NEEDED BUT NOT OPTIMIZED BECAUSE LISTS ARE RELOAD FULLY TO EACH XL FUNCTIONS CALL
    shader_set camera   := (camera_position at 1; camera_position at 2; camera_position at 3)
    shader_set model    := (model_matrix at 1;  model_matrix at 2;  model_matrix at 3;  model_matrix at 4;
                            model_matrix at 5;  model_matrix at 6;  model_matrix at 7;  model_matrix at 8;
                            model_matrix at 9;  model_matrix at 10; model_matrix at 11; model_matrix at 12;
                            model_matrix at 13; model_matrix at 14; model_matrix at 15; model_matrix at 16)
