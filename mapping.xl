// Mapping module definition
//
// This module defines commands to generate the Lorem ipsum sequence.
//
// Copyright 20010-2011 Taodyne

module_description
    id "a2cdbc99-ce81-42b2-a218-f51938ef2414"
    name "Mapping"
    import_name "Mapping"
    description ""
    version 1.0

// -------------------------------------------------------------------------------------------------------------------
//   GENERAL MAPPING PARAMETERS
// -------------------------------------------------------------------------------------------------------------------

color_map id:text ->
    /**
    * Set color map.
    **/
    texture_unit 0
    texture id

mapping t:tree ->
    /**
    * Apply mapping.
    **/
    locally
        do t

// -------------------------------------------------------------------------------------------------------------------
//   ALPHA MAPPING
// -------------------------------------------------------------------------------------------------------------------

//Define alpha thresold
ALPHA_THRESHOLD -> 0.01
ALPHA_THRESHOLD := 0.01

alpha_mapping n:real ->
    /**
    * Apply alpha mapping.
    **/
    ALPHA_THRESHOLD := n
    alpha_shader

alpha_map id:text ->
    /**
    * Set alpha map.
    **/
    texture_unit 1
    texture id

alpha_shader ->
    /**
    * Define alpha shader.
    **/
    shader_program
        vertex_shader <<
            void main()
            {
                gl_Position = ftransform();
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;
            }
        >>
        fragment_shader <<
            // Mapping paramaters
            uniform float     threshold;
            uniform sampler2D alphaMap;
            uniform sampler2D colorMap;

            void main()
            {
                vec4 alpha_color = texture2D(alphaMap, gl_TexCoord[1].st);

                // Filter alpha map according to the threshold
                if(alpha_color.r < threshold && alpha_color.g < threshold && alpha_color.b < threshold)
                    discard;

                gl_FragColor  = texture2D(colorMap, gl_TexCoord[0].st);
            }
        >>
    shader_set colorMap := 0
    shader_set alphaMap := 1
    shader_set threshold := ALPHA_THRESHOLD

// -------------------------------------------------------------------------------------------------------------------
//   DISPLACEMENT MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Displacement_mapping
//   or http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter08.html
// -------------------------------------------------------------------------------------------------------------------

// Define displacement offset
DISPLACEMENT_OFFSET -> 0.0
DISPLACEMENT_OFFSET := 0.0

displacement_mapping offset:real ->
    /**
    * Apply displacement.
    **/
    DISPLACEMENT_OFFSET := offset
    displacement_shader

displacement_map id:text ->
    /**
    * Set displacement map.
    **/
    texture_unit 1
    texture id

displacement_shader ->
    /**
    * Define displacement shader.
    **/
    shader_program
        vertex_shader <<
            // Mapping paramaters
            uniform float     coeff;
            uniform sampler2D displacementMap;

            void main()
            {
               vec4 newPos, dv;
               float df;

               // Compute texture coordinates
               gl_TexCoord[0] = gl_TextureMatrix[0] *  gl_MultiTexCoord0;
               gl_TexCoord[1] = gl_TextureMatrix[1] *  gl_MultiTexCoord1;

               // Calculate new vertex position according to its normal and its texture coordinates
               dv     = texture2D( displacementMap, gl_TexCoord[1].st );
               df     = 0.30 * dv.x + 0.59 * dv.y + 0.11 * dv.z;
               newPos = vec4(df * coeff * gl_Normal, 0.0) + gl_Vertex;

               // Compute position
               gl_Position = gl_ModelViewProjectionMatrix * newPos;
            }
        >>
        fragment_shader <<
            uniform sampler2D colorMap;
            void main()
            {
               gl_FragColor = texture2D(colorMap, gl_TexCoord[0].xy);
            }
        >>
    shader_set colorMap := 0
    shader_set displacementMap := 1
    shader_set coeff := DISPLACEMENT_OFFSET


// -------------------------------------------------------------------------------------------------------------------
//   NORMAL MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Normal_mapping
// -------------------------------------------------------------------------------------------------------------------

normal_mapping ->
    /**
    * Define displacement shader.
    **/
    normal_shader

normal_map id:text ->
    /**
    * Set normal map.
    **/
    texture_unit 1
    texture id

normal_shader ->
    /**
    * Define normal shader.
    **/
    shader_program
        vertex_shader <<
            varying vec3 lightDir;
            varying vec3 viewDir;
            varying vec3 normal;

            void main()
            {
                // Determine object parameterss
                gl_Position    = ftransform();
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;
                normal         = normalize(gl_NormalMatrix * gl_Normal);

                // Compute camera parameters
                vec3 eyePos = vec3(gl_ModelViewMatrix * gl_Vertex);

                // Compute direction parameters
                lightDir = normalize(gl_LightSource[0].position.xyz - eyePos);
                viewDir  = normalize(-eyePos);

            }
        >>
        fragment_shader <<
            // Mapping paramaters
            uniform sampler2D colorMap;
            uniform sampler2D normalMap;

            varying vec3 lightDir;
            varying vec3 viewDir;
            varying vec3 normal;

            /**
            /* Calculate tangent space matrix from normal, vector in plane
            *  and texture coordinates
            */
            mat3 computeTangentFrame(vec3 normal, vec3 position, vec2 texCoord)
            {
                // Compute derivatives
                vec3 dpx = dFdx(position);
                vec3 dpy = dFdy(position);
                vec2 dtx = dFdx(texCoord);
                vec2 dty = dFdy(texCoord);

                // Compute tangent and binormal
                vec3 tangent  = normalize(dpy * dtx.t - dpx * dty.t);
                vec3 binormal = cross(tangent, normal);

                return mat3(tangent, binormal, normal);
            }

            void main()
            {
                // Normalize vectors
                vec3 v = normalize(viewDir);
                vec3 l = normalize(lightDir);
                vec3 n = normalize(normal);

                // Compute bump coefficient according to normal map
                vec3 bump = normalize(texture2D(normalMap, gl_TexCoord[1].st).xyz * 2.0 - 1.0);

                // Calculate tangent space matrix
                mat3 TBN = computeTangentFrame(n, v, gl_TexCoord[1].st);

                // Define new normal
                n = TBN * bump;

                // Diffuse coefficient
                float nDotL = max(clamp(dot(l, n), 0.0, 1.0), 0.0);

                // Compute material parameters
                vec4 ambient  = gl_LightSource[0].ambient * gl_FrontMaterial.ambient;
                vec4 diffuse  = gl_LightSource[0].diffuse * gl_FrontMaterial.diffuse * nDotL;
                vec4 specular = 0;

                if (nDotL > 0.0)
                {
                    // Compute specular coefficient
                    float nDotV = clamp(dot(reflect(-l, n), v), 0.0, 1.0);
                    specular    = gl_LightSource[0].specular * gl_FrontMaterial.specular * pow(nDotV, gl_FrontMaterial.shininess);
                }

                // Define new render color
                vec3 color   = (gl_FrontLightModelProduct.sceneColor + ambient + diffuse) * texture2D(colorMap, gl_TexCoord[0].st).rgb  + specular.rgb;
                gl_FragColor = vec4(color, 1.0);
            }
        >>

    shader_set colorMap := 0
    shader_set normalMap := 1

