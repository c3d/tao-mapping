// Mapping module definition
//
// This module defines mapping techniques.
//
// Copyright 20010-2011 Taodyne

module_description
    id "a2cdbc99-ce81-42b2-a218-f51938ef2414"
    name "Mapping"
    import_name "Mapping"
    description "Allow to add details in a scene thanks to a surface texture"
    author "Taodyne SAS"
    website "http://www.taodyne.com"
    version "1.0"

module_description "fr",
    name "Mappage"
    description "Permet d'ajouter des détails visuels dans une scène à partir d'images."

// -------------------------------------------------------------------------------------------------------------------
//   ALPHA MAPPING
// -------------------------------------------------------------------------------------------------------------------

//Define alpha thresold
ALPHA_THRESHOLD -> 0.01
ALPHA_THRESHOLD := 0.01

alpha_mapping n:real ->
    /**
    * Apply alpha mapping.
    **/
    ALPHA_THRESHOLD := n
    alpha_shader

alpha_shader ->
    /**
    * Define alpha shader.
    **/
    shader_program
        vertex_shader <<
            void main()
            {
                // Compute position
                gl_Position = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;
            }
        >>
        fragment_shader <<
            // Mapping paramaters
            uniform float     threshold;
            uniform sampler2D alphaMap;
            uniform sampler2D colorMap;

            void main()
            {
                vec4 alpha_color = texture2D(alphaMap, gl_TexCoord[1].st);

                // Filter alpha map according to the threshold
                if(alpha_color.r < threshold && alpha_color.g < threshold && alpha_color.b < threshold)
                    discard;

                gl_FragColor  = texture2D(colorMap, gl_TexCoord[0].st);
            }
        >>
    shader_set colorMap  := 0
    shader_set alphaMap  := 1
    shader_set threshold := ALPHA_THRESHOLD

// -------------------------------------------------------------------------------------------------------------------
//   DISPLACEMENT MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Displacement_mapping
//   or http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter08.html
// -------------------------------------------------------------------------------------------------------------------

// Define displacement ratio
DISPLACEMENT_RATIO -> 0.0
DISPLACEMENT_RATIO := 0.0

displacement_mapping ratio:real ->
    /**
    * Apply displacement mapping.
    **/
    DISPLACEMENT_RATIO := ratio
    displacement_shader

displacement_shader ->
    /**
    * Define displacement shader.
    **/
    shader_program
        vertex_shader <<
            // Mapping paramaters
            uniform float     ratio;
            uniform sampler2D displacementMap;

            void main()
            {
               vec4 newPos, dv;
               float df;

               // Compute texture coordinates
               gl_TexCoord[0] = gl_TextureMatrix[0] *  gl_MultiTexCoord0;
               gl_TexCoord[1] = gl_TextureMatrix[1] *  gl_MultiTexCoord1;

               // Calculate new vertex position according to its normal and its texture coordinates
               dv     = texture2D( displacementMap, gl_TexCoord[1].st );
               df     = 0.30 * dv.x + 0.59 * dv.y + 0.11 * dv.z;
               newPos = vec4(df * ratio * gl_Normal, 0.0) + gl_Vertex;

               // Compute position
               gl_Position = gl_ModelViewProjectionMatrix * newPos;
            }
        >>
        fragment_shader <<
            uniform sampler2D colorMap;
            void main()
            {
               gl_FragColor = texture2D(colorMap, gl_TexCoord[0].xy);
            }
        >>
    shader_set colorMap        := 0
    shader_set displacementMap := 1
    shader_set ratio           := DISPLACEMENT_RATIO

// -------------------------------------------------------------------------------------------------------------------
//   NORMAL MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Normal_mapping
// -------------------------------------------------------------------------------------------------------------------

normal_mapping ->
    /**
    * Apply normal mapping.
    **/
    normal_shader

normal_shader ->
    /**
    * Define normal shader.
    **/
    shader_program
        vertex_shader <<
            varying vec3 lightDir;
            varying vec3 viewDir;
            varying vec3 normal;

            void main()
            {
                // Determine object parameters
                gl_Position    = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;

                // Compute world position and normal
                normal      = gl_NormalMatrix * gl_Normal;
                vec3 eyePos = vec3(gl_ModelViewMatrix * gl_Vertex);

                // Compute direction parameters
                lightDir = gl_LightSource[0].position.xyz - eyePos;
                viewDir  = normalize(-eyePos);
            }
        >>
        fragment_shader <<
            // Mapping paramaters
            uniform sampler2D colorMap;
            uniform sampler2D normalMap;

            varying vec3 lightDir;
            varying vec3 viewDir;
            varying vec3 normal;

            /**
            /* Calculate tangent space matrix from normal, vector in plane
            *  and texture coordinates
            */
            mat3 computeTangentFrame(vec3 normal, vec3 position, vec2 texCoord)
            {
                // Compute derivatives
                vec3 dpx = dFdx(position);
                vec3 dpy = dFdy(position);
                vec2 dtx = dFdx(texCoord);
                vec2 dty = dFdy(texCoord);

                // Compute tangent and binormal
                vec3 tangent  = normalize(dpy * dtx.t - dpx * dty.t);
                vec3 binormal = cross(tangent, normal);

                return mat3(tangent, binormal, normal);
            }

            void main()
            {
                // Normalize vectors
                vec3 l = normalize(lightDir);
                vec3 n = normalize(normal);

                // Compute bump coefficient according to normal map
                vec3 bump = normalize(texture2D(normalMap, gl_TexCoord[1].st).xyz * 2.0 - 1.0);

                // Calculate tangent space matrix
                mat3 TBN = computeTangentFrame(n, v, gl_TexCoord[1].st);

                // Define new normal
                n = TBN * bump;

                // Diffuse coefficient
                float nDotL = max(clamp(dot(l, n), 0.0, 1.0), 0.0);

                // Compute material parameters
                vec4 ambient  = gl_LightSource[0].ambient * gl_FrontMaterial.ambient;
                vec4 diffuse  = gl_LightSource[0].diffuse * gl_FrontMaterial.diffuse * nDotL;
                vec4 specular = 0;

                if (nDotL > 0.0)
                {
                    // Compute specular coefficient
                    float nDotV = clamp(dot(reflect(-l, n), v), 0.0, 1.0);
                    specular    = gl_LightSource[0].specular * gl_FrontMaterial.specular * pow(nDotV, gl_FrontMaterial.shininess);
                }

                // Define new render color
                vec3 color   = (gl_FrontLightModelProduct.sceneColor + ambient + diffuse) * texture2D(colorMap, gl_TexCoord[0].st).rgb  + specular.rgb;
                gl_FragColor = vec4(color, 1.0);
            }
        >>

    shader_set colorMap  := 0
    shader_set normalMap := 1

// -------------------------------------------------------------------------------------------------------------------
//   NOISE MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Image_noise
// -------------------------------------------------------------------------------------------------------------------

// Define noise ratio
NOISE_RATIO -> 0.0
NOISE_RATIO := 0.0

noise_mapping n->
    /**
    * Apply noise mapping.
    **/
    NOISE_RATIO := n
    noise_shader

noise_map w:integer, h:integer->
    /**
    * Generate a random noise image.
    **/
    frame_texture w, h,
        color "white"
        generate_noise
        rectangle 0, 0, w, h

noise_shader ->
    /**
    * Define noise shader.
    **/
    shader_program
        vertex_shader <<
            varying vec3 v;
            void main()
            {
                // Compute position
                gl_Position    = ftransform();

                // Compute texture coordinates
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;
            }
        >>
        fragment_shader <<
            // Mapping parameters
            uniform float     ratio;
            uniform sampler2D colorMap;
            uniform sampler2D noiseMap;

            void main()
            {
                // Get noise value from noise map.
                vec4 noise = texture2D(noiseMap, gl_TexCoord[1].st );

                // Compute noise coordinates
                vec2 noiseCoord = gl_TexCoord[0].st + vec2( noise.r * 0.065, -noise.g * 0.025 ) *  ratio / 10;

                // Apply noise coordinates to color map
                gl_FragColor = texture2D(colorMap, noiseCoord );
            }
        >>
    shader_set colorMap := 0
    shader_set noiseMap := 1
    shader_set ratio    := NOISE_RATIO

generate_noise ->
    /**
    * Generate noise effect.
    **/
    shader_program
        vertex_shader <<
            void main()
            {
               gl_TexCoord[0] = gl_Vertex;
               gl_Position    = ftransform();
            }
        >>
        fragment_shader <<
            // Pseudo random number base generator use to make noise
            float noise(vec2 v)
            {
                int n;
                n = v.x * 40 + v.y * 6400;
                n = (n << 13) ^ n;

                return 1.0 - float( (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0;
            }

            void main()
            {
                float noiseColor = (noise(gl_TexCoord[0].st) + 1.0) * 0.5;
                gl_FragColor     = vec4(noiseColor, noiseColor, noiseColor, 1);
            }
        >>

// -------------------------------------------------------------------------------------------------------------------
//   CUBE MAP
//   For further informations, see http://wiki.polycount.com/CubeMap
// -------------------------------------------------------------------------------------------------------------------

cube_map t:tree->
    /**
    * Create a cube map.
    **/
    texture_cube_shader
    texture_cube t

texture_cube_shader ->
    /**
    * Define shader to apply cube map.
    **/
    shader_program
        vertex_shader <<
            void main()
            {
                // Generate texture coordinates (equivalent to glTexGen)
                vec4 xPlane = vec4( 1.0f, 0.0f, 0.0f, 0.0f );
                vec4 yPlane = vec4( 0.0f, 1.0f, 0.0f, 0.0f );
                vec4 zPlane = vec4( 0.0f, 0.0f, 1.0f, 0.0f );

                gl_TexCoord[0].x = dot(vec4(gl_Vertex.xyz, 1.0), xPlane);
                gl_TexCoord[0].y = dot(vec4(gl_Vertex.xyz, 1.0), yPlane);
                gl_TexCoord[0].z = dot(vec4(gl_Vertex.xyz, 1.0), zPlane);

                // Compute position
                gl_Position = ftransform();
            }
        >>
        fragment_shader <<
            // Mapping parameters
            uniform samplerCube cubeMap;

            void main()
            {
                vec3 cube     = textureCube(cubeMap, gl_TexCoord[0].xyz).rgb;
                gl_FragColor  = vec4(cube, 1.0);
            }
        >>
    shader_set cubeMap := texture_unit


// -------------------------------------------------------------------------------------------------------------------
//   CUBE MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Cube_mapping
// -------------------------------------------------------------------------------------------------------------------

// Define cube mapping ratio
CUBE_RATIO -> 0.0
CUBE_RATIO := 0.0

cube_mapping r:real->
    /**
    * Apply cube mapping.
    **/
    CUBE_RATIO := r
    cube_shader

cube_shader ->
    /**
    * Define cube mapping shader.
    **/
    shader_program
        shader_log
        vertex_shader <<
            mat3 linearPart( mat4 m )
            {
                mat3 result;

                result[0][0] = m[0][0];
                result[0][1] = m[0][1];
                result[0][2] = m[0][2];

                result[1][0] = m[1][0];
                result[1][1] = m[1][1];
                result[1][2] = m[1][2];

                result[2][0] = m[2][0];
                result[2][1] = m[2][1];
                result[2][2] = m[2][2];

                return result;
            }

            uniform mat4 model;
            uniform vec3 camera;
            void main()
            {
                // Compute world position and normal
                vec4 worldPos = model * gl_Vertex;
                vec3 normal   = normalize(linearPart(model) * gl_Normal);
                vec3 eyePos   = normalize(worldPos.xyz - camera);

                // Compute reflection vector
                vec3 r = reflect (eyePos, normal);

                // Compute texture coordinates
                gl_TexCoord[1] = gl_TextureMatrix[1] * vec4 (r, 1.0);
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;

                // Compute position
                gl_Position = ftransform();
            }
        >>
        fragment_shader <<
            // Mapping parameters
            uniform float       ratio;
            uniform sampler2D   colorMap;
            uniform samplerCube cubeMap;

            void main()
            {
                vec3 cube     = textureCube(cubeMap, gl_TexCoord[1].xyz).rgb;
                vec3 color    = texture2D(colorMap, gl_TexCoord[0].st).rgb;
                gl_FragColor  = vec4(mix(color, cube, ratio), 1.0);
            }
        >>
    shader_set colorMap := 0
    shader_set cubeMap  := 1
    shader_set ratio    := CUBE_RATIO

    //FOLLOWING PARAMETERS ARE NEEDED BUT NOT OPTIMIZED BECAUSE LISTS ARE RELOAD FULLY TO EACH XL FUNCTIONS CALL
    shader_set camera   := (camera_position at 1; camera_position at 2; camera_position at 3)
    shader_set model    := (model_matrix at 1;  model_matrix at 2;  model_matrix at 3;  model_matrix at 4;
                            model_matrix at 5;  model_matrix at 6;  model_matrix at 7;  model_matrix at 8;
                            model_matrix at 9;  model_matrix at 10; model_matrix at 11; model_matrix at 12;
                            model_matrix at 13; model_matrix at 14; model_matrix at 15; model_matrix at 16)

// -------------------------------------------------------------------------------------------------------------------
//   SPHERE MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Sphere_mapping
// -------------------------------------------------------------------------------------------------------------------

// Define sphere mapping ratio
SPHERE_RATIO -> 0.0
SPHERE_RATIO := 0.0

sphere_mapping r:real->
    /**
    * Apply sphere mapping.
    **/
    SPHERE_RATIO := r
    sphere_shader

sphere_shader ->
    /**
    * Define sphere mapping shader.
    **/
    shader_program
        vertex_shader <<
            void main()
            {
                // Determine object parameters
                gl_Position    = ftransform();
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;

                // Compute world position and normal
                vec3 normal = normalize( gl_NormalMatrix * gl_Normal );
                vec3 eyePos = normalize( vec3(gl_ModelViewMatrix * gl_Vertex) );

                // Compute camera parameters
                vec3  r  = reflect( eyePos, normal );
                float m  = 2.0 * sqrt( r.x * r.x + r.y * r.y + (r.z + 1.0) * (r.z + 1.0) );

                // Compute sphere coordinates
                gl_TexCoord[1].s = r.x/m + 0.5;
                gl_TexCoord[1].t = r.y/m + 0.5;
          }
        >>
        fragment_shader <<
            // Mapping parameters
            uniform float     ratio;
            uniform sampler2D colorMap;
            uniform sampler2D sphereMap;

            void main()
            {
                vec3 color   = texture2D( colorMap, gl_TexCoord[0].st).rgb;
                vec3 sphere  = texture2D( sphereMap, gl_TexCoord[1].st).rgb;
                gl_FragColor = vec4(mix(color, sphere, ratio), 1.0);
            }
        >>
    shader_set colorMap  := 0
    shader_set sphereMap := 1
    shader_set ratio     := SPHERE_RATIO


// -------------------------------------------------------------------------------------------------------------------
//   REFLECTION MAPPING
//   For further informations, see http://en.wikipedia.org/wiki/Reflection_mapping
// -------------------------------------------------------------------------------------------------------------------

// Define reflection mapping ratio
REFLECTION_RATIO -> 0.0
REFLECTION_RATIO := 0.0

reflection_mapping r:real->
    /**
    * Apply reflection mapping.
    **/
    REFLECTION_RATIO := r
    reflection_shader

reflection_shader ->
    /**
    * Define reflection mapping shader.
    **/
    shader_program
        vertex_shader <<
            void main()
            {
                // Compute world position and normal
                vec3 normal = normalize (gl_NormalMatrix * gl_Normal);
                vec3 eyePos = normalize(vec3(gl_ModelViewMatrix * gl_Vertex));

                // Compute reflection vector
                vec3 r = normalize(reflect (eyePos, normal));

                // Compute texture coordinates
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                gl_TexCoord[1].x = (r.x / 2.0) + 0.5 ;
                gl_TexCoord[1].y = (r.y / 2.0) + 0.5 ;

                // Compute position
                gl_Position = ftransform();
            }
        >>
        fragment_shader <<
            // Mapping parameters
            uniform float       ratio;
            uniform sampler2D   colorMap;
            uniform sampler2D   cubeMap;

            void main()
            {
                vec3 cube     = texture2D(cubeMap, gl_TexCoord[1].xy).rgb;
                vec3 color    = texture2D(colorMap, gl_TexCoord[0].st).rgb;
                gl_FragColor  = vec4(mix(color, cube, ratio), 1.0);
            }
        >>
    shader_set colorMap := 0
    shader_set cubeMap  := 1
    shader_set ratio    := REFLECTION_RATIO


